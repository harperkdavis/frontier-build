{"mappings":"ACyBwB,IAAI,gBAAgB,OAAO,QAAQ,CAAC,MAAM,EAAE,GAAG,CAAC,S,4D","sources":["<anon>","src/sketch.js"],"sourcesContent":["const input = {\n    keys: {},\n    mouse: {}\n};\nconst game = {};\nconst CP_437 = [\n    \" \",\n    \"\\u263A\",\n    \"\\u263B\",\n    \"\\u2665\",\n    \"\\u2666\",\n    \"\\u2663\",\n    \"\\u2660\",\n    \"\\u2022\",\n    \"\\u25D8\",\n    \"\\u25CB\",\n    \"\\u25D9\",\n    \"\\u2642\",\n    \"\\u2640\",\n    \"\\u266A\",\n    \"\\u266B\",\n    \"\\u263C\",\n    \"\\u25BA\",\n    \"\\u25C4\",\n    \"\\u2195\",\n    \"\\u203C\",\n    \"\\xb6\",\n    \"\\xa7\",\n    \"\\u25AC\",\n    \"\\u21A8\",\n    \"\\u2191\",\n    \"\\u2193\",\n    \"\\u2192\",\n    \"\\u2190\",\n    \"\\u221F\",\n    \"\\u2194\",\n    \"\\u25B2\",\n    \"\\u25BC\",\n    \" \",\n    \"!\",\n    '\"',\n    \"#\",\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"(\",\n    \")\",\n    \"*\",\n    \"+\",\n    \",\",\n    \"-\",\n    \".\",\n    \"/\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \":\",\n    \";\",\n    \"<\",\n    \"=\",\n    \">\",\n    \"?\",\n    \"@\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \"[\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"{\",\n    \"|\",\n    \"}\",\n    \"~\",\n    \"\\u2302\",\n    \"\\xc7\",\n    \"\\xfc\",\n    \"\\xe9\",\n    \"\\xe2\",\n    \"\\xe4\",\n    \"\\xe0\",\n    \"\\xe5\",\n    \"\\xe7\",\n    \"\\xea\",\n    \"\\xeb\",\n    \"\\xe8\",\n    \"\\xef\",\n    \"\\xee\",\n    \"\\xec\",\n    \"\\xc4\",\n    \"\\xc5\",\n    \"\\xc9\",\n    \"\\xe6\",\n    \"\\xc6\",\n    \"\\xf4\",\n    \"\\xf6\",\n    \"\\xf2\",\n    \"\\xfb\",\n    \"\\xf9\",\n    \"\\xff\",\n    \"\\xd6\",\n    \"\\xdc\",\n    \"\\xa2\",\n    \"\\xa3\",\n    \"\\xa5\",\n    \"\\u20A7\",\n    \"\\u0192\",\n    \"\\xe1\",\n    \"\\xed\",\n    \"\\xf3\",\n    \"\\xfa\",\n    \"\\xf1\",\n    \"\\xd1\",\n    \"\\xaa\",\n    \"\\xba\",\n    \"\\xbf\",\n    \"\\u2310\",\n    \"\\xac\",\n    \"\\xbd\",\n    \"\\xbc\",\n    \"\\xa1\",\n    \"\\xab\",\n    \"\\xbb\",\n    \"\\u2591\",\n    \"\\u2592\",\n    \"\\u2593\",\n    \"\\u2502\",\n    \"\\u2524\",\n    \"\\u2561\",\n    \"\\u2562\",\n    \"\\u2556\",\n    \"\\u2555\",\n    \"\\u2563\",\n    \"\\u2551\",\n    \"\\u2557\",\n    \"\\u255D\",\n    \"\\u255C\",\n    \"\\u255B\",\n    \"\\u2510\",\n    \"\\u2514\",\n    \"\\u2534\",\n    \"\\u252C\",\n    \"\\u251C\",\n    \"\\u2500\",\n    \"\\u253C\",\n    \"\\u255E\",\n    \"\\u255F\",\n    \"\\u255A\",\n    \"\\u2554\",\n    \"\\u2569\",\n    \"\\u2566\",\n    \"\\u2560\",\n    \"\\u2550\",\n    \"\\u256C\",\n    \"\\u2567\",\n    \"\\u2568\",\n    \"\\u2564\",\n    \"\\u2565\",\n    \"\\u2559\",\n    \"\\u2558\",\n    \"\\u2552\",\n    \"\\u2553\",\n    \"\\u256B\",\n    \"\\u256A\",\n    \"\\u2518\",\n    \"\\u250C\",\n    \"\\u2588\",\n    \"\\u2584\",\n    \"\\u258C\",\n    \"\\u2590\",\n    \"\\u2580\",\n    \"\\u03B1\",\n    \"\\xdf\",\n    \"\\u0393\",\n    \"\\u03C0\",\n    \"\\u03A3\",\n    \"\\u03C3\",\n    \"\\xb5\",\n    \"\\u03C4\",\n    \"\\u03A6\",\n    \"\\u0398\",\n    \"\\u03A9\",\n    \"\\u03B4\",\n    \"\\u221E\",\n    \"\\u03C6\",\n    \"\\u03B5\",\n    \"\\u2229\",\n    \"\\u2261\",\n    \"\\xb1\",\n    \"\\u2265\",\n    \"\\u2264\",\n    \"\\u2320\",\n    \"\\u2321\",\n    \"\\xf7\",\n    \"\\u2248\",\n    \"\\xb0\",\n    \"\\u2219\",\n    \"\\xb7\",\n    \"\\u221A\",\n    \"\\u207F\",\n    \"\\xb2\",\n    \"\\u25A0\",\n    \" \"\n];\nconst COLORS = [\n    \"#ff0040\",\n    \"#131313\",\n    \"#1b1b1b\",\n    \"#272727\",\n    \"#3d3d3d\",\n    \"#5d5d5d\",\n    \"#858585\",\n    \"#b4b4b4\",\n    \"#ffffff\",\n    \"#c7cfdd\",\n    \"#92a1b9\",\n    \"#657392\",\n    \"#424c6e\",\n    \"#2a2f4e\",\n    \"#1a1932\",\n    \"#0e071b\",\n    \"#1c121c\",\n    \"#391f21\",\n    \"#5d2c28\",\n    \"#8a4836\",\n    \"#bf6f4a\",\n    \"#e69c69\",\n    \"#f6ca9f\",\n    \"#f9e6cf\",\n    \"#edab50\",\n    \"#e07438\",\n    \"#c64524\",\n    \"#8e251d\",\n    \"#ff5000\",\n    \"#ed7614\",\n    \"#ffa214\",\n    \"#ffc825\",\n    \"#ffeb57\",\n    \"#d3fc7e\",\n    \"#99e65f\",\n    \"#5ac54f\",\n    \"#33984b\",\n    \"#1e6f50\",\n    \"#134c4c\",\n    \"#0c2e44\",\n    \"#00396d\",\n    \"#0069aa\",\n    \"#0098dc\",\n    \"#00cdf9\",\n    \"#0cf1ff\",\n    \"#94fdff\",\n    \"#fdd2ed\",\n    \"#f389f5\",\n    \"#db3ffd\",\n    \"#7a09fa\",\n    \"#3003d9\",\n    \"#0c0293\",\n    \"#03193f\",\n    \"#3b1443\",\n    \"#622461\",\n    \"#93388f\",\n    \"#ca52c9\",\n    \"#c85086\",\n    \"#f68187\",\n    \"#f5555d\",\n    \"#ea323c\",\n    \"#c42430\",\n    \"#891e2b\",\n    \"#571c27\"\n];\nlet Fonts = {};\nlet tick = 0;\nconst EDITOR = new URLSearchParams(window.location.search).get(\"editor\") != null;\nfunction preload() {\n    Fonts = {\n        pixel: loadFont(\"./static/font/PxPlus_IBM_EGA_8x8.ttf\"),\n        regular: loadFont(\"./static/font/LibreFranklin-Regular.ttf\"),\n        bold: loadFont(\"./static/font/LibreFranklin-Bold.ttf\")\n    };\n}\nfunction setup() {\n    createCanvas();\n    windowResized();\n    textFont(Fonts.pixel);\n    textSize(16);\n    if (EDITOR) document.getElementById(\"editor\").style.display = \"block\";\n    game.world = new World();\n    const naturalItems = REGISTRY.items.filter((item)=>item.tags.includes(\"natural\")).map((item)=>item.id);\n    const totalWeight = naturalItems.reduce((acc, id)=>acc + (REGISTRY.getItem(id).properties.weight ?? 1), 0);\n    for(let i = 0; i < game.world.size * game.world.size / 16; i += 1){\n        const x = floor(random(game.world.size));\n        const y = floor(random(game.world.size));\n        if (x < 4 || x > game.world.size - 4 || y < 4 || y > game.world.size - 4) continue;\n        const w = random(totalWeight);\n        let acc = 0;\n        let item = null;\n        for (const id of naturalItems){\n            acc += REGISTRY.getItem(id).properties.weight ?? 1;\n            if (acc >= w) {\n                item = id;\n                break;\n            }\n        }\n        item = item || naturalItems[naturalItems.length - 1];\n        game.world.set(x, y, new ItemState(item));\n    }\n    game.world.set(floor(game.world.size / 2), floor(game.world.size) / 2, new ItemState(57));\n    game.camera = {\n        x: 0,\n        y: 0\n    };\n    game.people = [];\n    game.groups = [];\n    for(let i = 0; i < 5; i += 1){\n        const group = generateGroup(0, game.world);\n        game.groups.push(group[0].surname);\n        game.people.push(...group);\n    }\n    assignReputations(game.people);\n    game.acc = 0;\n    game.worldMouseX = 0;\n    game.worldMouseX = 0;\n    game.mouseIndex = 0;\n    game.tick = 0;\n    game.selectedPerson = \"\";\n    game.peopleGraph = new Array(50).fill(game.people.length);\n    game.itemsCrafted = {};\n    game.foodEaten = {};\n    game.deepestItem = 0;\n    game.deepestItemDepth = 0;\n    game.deepestItemCredit = \"\";\n    game.skip = 0;\n    game.temp = 0;\n    game.extraInfo = false;\n    game.renderData = {};\n// game.people = [ game.people[0] ];\n// game.people[0].x = 49;\n// game.people[0].y = 49;\n}\nfunction windowResized() {\n    resizeCanvas(windowWidth, windowHeight);\n}\nfunction keyPressed() {\n    input.keys[keyCode] = 0;\n}\nfunction keyReleased() {\n    input.keys[keyCode] = -1;\n}\nfunction mousePressed() {\n    input.mouse[mouseButton] = 0;\n}\nfunction mouseReleased() {\n    input.mouse[mouseButton] = -1;\n}\nfunction updateInput() {\n    for(let key in input.keys)if (input.keys[key] >= 0) input.keys[key] += 1;\n    for(let button in input.mouse)if (input.mouse[button] >= 0) input.mouse[button] += 1;\n}\nfunction isWithin(tx, ty, x, y, w, h) {\n    return tx >= x && tx <= x + w && ty >= y && ty <= y + h;\n}\nfunction mouseIsWithin(x, y, w, h) {\n    return isWithin(mouseX, mouseY, x, y, w, h);\n}\nfunction runTick() {\n    game.temp = sin(game.tick / 172800 * TWO_PI) * 10 - 5 - cos(game.tick / 1440 * TWO_PI) * 2;\n    game.world.update(game.temp);\n    for (const { item, x, y } of game.world.active()){\n        const timed = item.item.usedIn.find((use)=>use.time);\n        if (timed) {\n            if (timed.willOccur(item, null, game.tick * 60)) {\n                console.log(\"occured\");\n                const [result] = timed.getResults(item, null, Math.random());\n                result.time = game.tick * 60;\n                game.world.set(x, y, result);\n                freeChunk(floor(x / CHUNK_SIZE) + floor(y / CHUNK_SIZE) * WORLD_SIZE);\n            }\n        }\n    }\n    for (const person of game.people)person.update(game.world, game.temp);\n    for (const person of game.people)if (person.health <= 0) {\n        game.world.set(person.x, person.y, new ItemState(86)); // grave\n        freeChunk(floor(person.x / CHUNK_SIZE) + floor(person.y / CHUNK_SIZE) * WORLD_SIZE);\n    }\n    game.people = game.people.filter((person)=>person.health > 0);\n    for (const person of game.people)person.think(game.world, game.people, game.tick * 60);\n    let actions = {};\n    for (const person of game.people){\n        const action = person.act();\n        if (action) actions[person.id] = action;\n    }\n    for (const person of game.people){\n        const action = actions[person.id];\n        if (action.type === \"move\") {\n            const newX = person.x + (action.data.direction === 4 ? 1 : 0) + (action.data.direction === 2 ? -1 : 0);\n            const newY = person.y + (action.data.direction === 3 ? 1 : 0) + (action.data.direction === 1 ? -1 : 0);\n            if (newX < 0 || newX >= game.world.size || newY < 0 || newY >= game.world.size) continue;\n            if (game.world.get(newX, newY) && game.world.get(newX, newY).item.tags.includes(\"blocking\")) continue;\n            if (game.people.find((p)=>p.x === newX && p.y === newY)) continue;\n            person.x = newX;\n            person.y = newY;\n        } else if (action.type === \"eat\") {\n            if (person.holding != null) {\n                const item = person.holding.item;\n                if (item.tags.includes(\"edible\")) {\n                    game.foodEaten[item.id] = (game.foodEaten[item.id] || 0) + 1;\n                    person.hunger += item.properties[\"food\"] || 0;\n                    person.score += item.properties[\"food\"] || 0;\n                    person.holding = item.properties[\"leftovers\"] ? new ItemState(item.properties[\"leftovers\"]) : null;\n                }\n            }\n        } else if (action.type === \"interact\") {\n            const prev = game.world.get(person.x, person.y);\n            let intX = person.x + (action.data.direction === 4 ? 1 : 0) + (action.data.direction === 2 ? -1 : 0);\n            let intY = person.y + (action.data.direction === 3 ? 1 : 0) + (action.data.direction === 1 ? -1 : 0);\n            if (person.holding === null && game.world.get(intX, intY) != null) {\n                const item = game.world.get(intX, intY).item;\n                if (!item.tags.includes(\"static\")) {\n                    person.holding = game.world.get(intX, intY);\n                    game.world.set(intX, intY, null);\n                    freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n                } else if (item.usedIn.find((use)=>!use.actor)) {\n                    const recipe = item.usedIn.find((use)=>!use.actor);\n                    const [origin, actor] = recipe.getResults(game.world.get(intX, intY), null, Math.random());\n                    game.world.set(intX, intY, origin);\n                    freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n                    person.holding = actor;\n                    if (game.world.get(intX, intY)) {\n                        game.world.get(intX, intY).time = game.tick * 60;\n                        if (prev && origin.id !== prev.id) person.addItemToMemory(game.world, intX, intY, game.tick * 60);\n                    }\n                }\n            } else if (person.holding != null && game.world.get(intX, intY) == null) {\n                game.world.set(intX, intY, person.holding);\n                freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n                game.world.get(intX, intY).time = game.tick * 60;\n                person.holding = null;\n            } else if (person.holding != null && game.world.get(intX, intY) != null) {\n                const item = game.world.get(intX, intY).item;\n                for (const recipe of item.usedIn)if (recipe.willOccur(game.world.get(intX, intY), person.holding, game.tick * 60)) {\n                    const [origin, actor] = recipe.getResults(game.world.get(intX, intY), person.holding, Math.random());\n                    game.world.set(intX, intY, origin);\n                    freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n                    person.holding = actor;\n                    if (game.world.get(intX, intY)) {\n                        game.world.get(intX, intY).time = game.tick * 60;\n                        if (prev && origin.id !== prev.id) person.addItemToMemory(game.world, intX, intY, game.tick * 60);\n                    }\n                    break;\n                }\n            }\n            const runChecks = (item)=>{\n                if (item.item.tags.includes(\"important\")) person.score += item.item.depth() ** 2 * 10;\n                console.log(item.item.name, item.item.depth());\n                if (item.item.depth() > game.deepestItemDepth) {\n                    game.deepestItem = item.id;\n                    game.deepestItemDepth = item.item.depth();\n                    game.deepestItemCredit = person.fullName;\n                }\n                game.itemsCrafted[item.item.id] = (game.itemsCrafted[item.item.id] || 0) + 1;\n            };\n            game.world.get(intX, intY) && game.world.get(intX, intY).id !== 0 && runChecks(game.world.get(intX, intY));\n            person.holding && person.holding.id !== 0 && runChecks(person.holding);\n        }\n    }\n    game.tick += 1;\n    if (game.tick % 60 === 0) {\n        game.peopleGraph.shift();\n        game.peopleGraph.push(game.people.length);\n    }\n}\nfunction update() {\n    game.time = {\n        minute: game.tick % 60,\n        hour: floor(game.tick / 60) % 24,\n        day: floor(game.tick / 60 / 24) % 30,\n        month: floor(game.tick / 60 / 24 / 30) % 4,\n        year: floor(game.tick / 60 / 24 / 30 / 4) + 1000\n    };\n    if (mouseIsWithin(0, 0, 800, 800)) {\n        game.worldMouseX = floor(mouseX / 16) + game.camera.x;\n        game.worldMouseY = floor(mouseY / 16) + game.camera.y;\n    }\n    if (input.keys[LEFT_ARROW] > 0) game.camera.x -= 1;\n    if (input.keys[RIGHT_ARROW] > 0) game.camera.x += 1;\n    if (input.keys[UP_ARROW] > 0) game.camera.y -= 1;\n    if (input.keys[DOWN_ARROW] > 0) game.camera.y += 1;\n    if (input.keys[\"Q\".charCodeAt(0)] === 1) game.extraInfo = !game.extraInfo;\n    if (input.keys[\"P\".charCodeAt(0)] > 0) game.skip = 1440; // skip ahead 1 day\n    if (input.keys[\"O\".charCodeAt(0)] > 0) game.skip = 10080; // skip ahead 1 week\n    if (input.keys[\"I\".charCodeAt(0)] > 0) game.skip = 43200; // skip ahead 1 month\n    if (input.keys[\"U\".charCodeAt(0)] > 0) game.skip = 172800; // skip ahead 1 year\n    if (game.skip > 0) {\n        const start = millis();\n        let i = 0;\n        while(game.skip > 0 && millis() - start < 100){\n            runTick();\n            game.skip -= 1;\n            i += 1;\n        }\n        game.tps = i / ((millis() - start) / 1000);\n        return;\n    }\n    let dt = frameRate() > 0 ? 1 / frameRate() : 0;\n    game.acc += dt * 2 * (input.keys[\"T\".charCodeAt(0)] > 0 ? 100 : 1);\n    game.acc = min(game.acc, 200);\n    while(game.acc > 1){\n        game.acc -= 1;\n        runTick();\n    }\n    for (const person of game.people){\n        if (mouseIsWithin(0, 0, 800, 800)) {\n            if (person.x === game.worldMouseX && person.y === game.worldMouseY) game.selectedPerson = person.id;\n        }\n    }\n}\nfunction drawItem(display, x, y, to = window) {\n    if (display.length === 0) return;\n    const disp = display[tick % display.length];\n    const { character, color } = disp;\n    to.fill(COLORS[color]);\n    to.textFont(Fonts.pixel);\n    to.text(CP_437[character], x, y);\n}\nfunction drawNiceItem(display, x, y, size = 16) {\n    textAlign(LEFT, TOP);\n    textSize(size);\n    stroke(30);\n    fill(20);\n    rect(x, y, size, size);\n    noStroke();\n    drawItem(display, x, y);\n}\nfunction drawNiceNoun(noun, x, y, size = 16) {\n    let message = \"\";\n    textAlign(LEFT, TOP);\n    switch(noun.type){\n        case \"person\":\n            const person = game.people.find((person)=>person.id === noun.data.id);\n            drawNiceItem((person || REGISTRY.getItem(86)).display, x, y, size);\n            message = person ? person.fullName : \"dead\";\n            break;\n        case \"place\":\n            stroke(30);\n            fill(20);\n            rect(x, y, size, size);\n            noFill();\n            stroke(255);\n            const miniX = x + map(noun.data.x, 0, game.world.size, 0, size);\n            const miniY = y + map(noun.data.y, 0, game.world.size, 0, size);\n            line(miniX - 1, miniY - 1, miniX + 1, miniY + 1);\n            line(miniX - 1, miniY + 1, miniX + 1, miniY - 1);\n            message = `${noun.data.x}, ${noun.data.y}`;\n            break;\n        case \"thing\":\n            const query = REGISTRY.query(noun.data.selector);\n            let display = query.map((id)=>REGISTRY.getItem(id).display).flat();\n            if (display.length === 0) display = REGISTRY.getItem(0).display;\n            drawNiceItem(display, x, y, size);\n            message = query.map((id)=>REGISTRY.getItem(id).name).join(\", \");\n            break;\n    }\n    if (mouseIsWithin(x, y, size, size)) {\n        textFont(Fonts.regular);\n        const w = min(textWidth(message), 300);\n        textAlign(CENTER, BOTTOM);\n        textSize(16);\n        stroke(255);\n        fill(0);\n        rect(x - w / 2 - 10, y - 50, w + 20, 40);\n        fill(255);\n        noStroke();\n        text(message, x, y - 20);\n        textAlign(LEFT, TOP);\n    }\n}\nfunction drawMemory(memory, x, y) {\n    noStroke();\n    switch(memory.type){\n        case \"exists\":\n            drawNiceNoun(memory.data.noun, x, y);\n            textFont(Fonts.regular);\n            fill(255);\n            text(\"exists\", x + 20, y);\n            break;\n        case \"location\":\n            drawNiceNoun(memory.data.noun, x, y);\n            textFont(Fonts.regular);\n            fill(255);\n            text(\"is at\", x + 20, y);\n            drawNiceNoun({\n                type: \"place\",\n                data: {\n                    x: memory.data.x,\n                    y: memory.data.y\n                }\n            }, x + 55, y);\n            break;\n        case \"personKnows\":\n            drawNiceNoun(memory.data.person, x, y);\n            textFont(Fonts.regular);\n            fill(255);\n            text(\"knows\", x + 20, y);\n            drawMemory(memory.data.memory, x + 50, y);\n            break;\n    }\n}\nfunction drawObjective(objective, x, y) {\n    noStroke();\n    textAlign(LEFT, TOP);\n    textSize(16);\n    textFont(Fonts.regular);\n    fill(255);\n    switch(objective.type){\n        case \"fulfillNeed\":\n            text(objective.data.need, x, y);\n            break;\n        case \"obtain\":\n            text(\"obtain\", x, y);\n            drawNiceNoun(objective.data.noun, x + 60, y);\n            if (objective.data.another) {\n                textFont(Fonts.bold);\n                text(\"(another)\", x + 80, y);\n            }\n            break;\n    }\n}\nfunction jumpToPerson(person) {\n    game.camera.x = person.x - 25;\n    game.camera.y = person.y - 25;\n    game.selectedPerson = person.id;\n}\nfunction freeChunk(index) {\n    if (game.renderData[index]) {\n        game.renderData[index].static.remove();\n        delete game.renderData[index];\n    }\n}\nfunction drawStaticChunk(chunk) {\n    const graphics = createGraphics(CHUNK_SIZE * 16, CHUNK_SIZE * 16);\n    graphics.textSize(16);\n    graphics.textAlign(LEFT, TOP);\n    for(let x = 0; x < CHUNK_SIZE; x += 1)for(let y = 0; y < CHUNK_SIZE; y += 1){\n        const item = chunk.items[x + y * CHUNK_SIZE];\n        if (item && item.item.display.length === 1) drawItem(item.item.display, x * 16, y * 16, graphics);\n    }\n    return graphics;\n}\nfunction mod(n, m) {\n    return (n % m + m) % m;\n}\nfunction draw() {\n    tick = floor(millis() / 500);\n    if (EDITOR) {\n        updateInput();\n        drawEditor();\n        return;\n    }\n    update();\n    updateInput();\n    background(0);\n    textSize(16);\n    fill(255);\n    textAlign(LEFT, TOP);\n    textFont(Fonts.regular);\n    if (game.skip > 0) {\n        text(\"Skipping ahead... ticks: \" + game.skip, 10, 10);\n        text(\"tps: \" + game.tps, 10, 30);\n        text(\"people left: \" + game.people.length, 10, 50);\n        if (input.keys[ESCAPE] > 0) game.skip = 0;\n        return;\n    }\n    noStroke();\n    fill(10);\n    rect(0, 0, 800, 800);\n    fill(10);\n    textAlign(LEFT, TOP);\n    for(let x = 0; x < 50; x += 1)for(let y = 0; y < 50; y += 1){\n        const cx = x + game.camera.x;\n        const cy = y + game.camera.y;\n        if (cx < 0 || cx >= game.world.size || cy < 0 || cy >= game.world.size) continue;\n        const item = game.world.get(cx, cy);\n        if (item != null && item.item.tags.includes(\"heatSource\")) {\n            stroke(255, 63, 0, 200);\n            fill(255, 63, 0, 40);\n            noStroke();\n            ellipse((x + 0.5) * 16, (y + 0.5) * 16, 16 * item.item.properties.heat, 16 * item.item.properties.heat);\n        }\n    }\n    stroke(30);\n    beginShape(LINES);\n    for(let i = 0; i < 50; i += 1){\n        if (i + game.camera.x >= 0 && i + game.camera.x <= game.world.size) {\n            vertex(i * 16, 0);\n            vertex(i * 16, 800);\n        }\n        if (i + game.camera.y >= 0 && i + game.camera.y <= game.world.size) {\n            vertex(0, i * 16);\n            vertex(800, i * 16);\n        }\n    }\n    stroke(50);\n    for(let i = 0; i < 50; i += 1){\n        if ((i + game.camera.x) % 10 === 0 && i + game.camera.x >= 0 && i + game.camera.x <= game.world.size) {\n            vertex(i * 16, 0);\n            vertex(i * 16, 800);\n        }\n        if ((i + game.camera.y) % 10 === 0 && i + game.camera.y >= 0 && i + game.camera.y <= game.world.size) {\n            vertex(0, i * 16);\n            vertex(800, i * 16);\n        }\n    }\n    endShape();\n    noFill();\n    rect(0, 0, 800, 800);\n    for(let x = 0; x <= 50 / CHUNK_SIZE; x += 1)for(let y = 0; y <= 50 / CHUNK_SIZE; y += 1){\n        const cx = x + floor(game.camera.x / CHUNK_SIZE);\n        const cy = y + floor(game.camera.y / CHUNK_SIZE);\n        if (cx < 0 || cx >= WORLD_SIZE || cy < 0 || cy >= WORLD_SIZE) continue;\n        const index = cx + cy * WORLD_SIZE;\n        if (!game.renderData[index]) game.renderData[index] = {\n            static: drawStaticChunk(game.world.chunks[index]),\n            dynamic: Object.entries(game.world.chunks[index].items).filter(([i, item])=>item && item.item.display.length > 1).map(([i, item])=>({\n                    x: i % CHUNK_SIZE * 16,\n                    y: floor(i / CHUNK_SIZE) * 16,\n                    item\n                }))\n        };\n        if (game.renderData[index]) {\n            image(game.renderData[index].static, x * CHUNK_SIZE * 16 - mod(game.camera.x, CHUNK_SIZE) * 16, y * CHUNK_SIZE * 16 - mod(game.camera.y, CHUNK_SIZE) * 16);\n            noStroke();\n            for (const { x: dx, y: dy, item } of game.renderData[index].dynamic)drawItem(item.item.display, x * CHUNK_SIZE * 16 - mod(game.camera.x, CHUNK_SIZE) * 16 + dx, y * CHUNK_SIZE * 16 - mod(game.camera.y, CHUNK_SIZE) * 16 + dy);\n        }\n    }\n    for(const index in game.renderData){\n        const x = index % WORLD_SIZE;\n        const y = floor(index / WORLD_SIZE);\n        if (x < floor(game.camera.x / CHUNK_SIZE) - 4 || x > floor((game.camera.x + 50) / CHUNK_SIZE) + 4 || y < floor(game.camera.y / CHUNK_SIZE) - 4 || y > floor((game.camera.y + 50) / CHUNK_SIZE) + 4) freeChunk(index);\n    }\n    for (const person of game.people)if (person.x > game.camera.x && person.x < game.camera.x + 50 && person.y > game.camera.y && person.y < game.camera.y + 50) {\n        noFill();\n        stroke(COLORS[person.altColor]);\n        rect((person.x - game.camera.x) * 16 - 2, (person.y - game.camera.y) * 16 - 2, 20, 20);\n        noStroke();\n        drawItem(person.display, (person.x - game.camera.x) * 16, (person.y - game.camera.y) * 16);\n    }\n    stroke(255);\n    fill(0);\n    rect(810, 10, 200, 100);\n    stroke(100);\n    noFill();\n    beginShape();\n    const peopleGraphMax = max(...game.peopleGraph);\n    for(let i = 0; i < game.peopleGraph.length; i += 1){\n        const x = 820 + map(i, 0, game.peopleGraph.length - 1, 0, 100);\n        const y = 110 - map(game.peopleGraph[i], 0, peopleGraphMax, 0, 30);\n        vertex(x, y);\n    }\n    endShape();\n    noStroke();\n    fill(0);\n    rect(0, 800, width, height - 800);\n    rect(800, 0, width - 800, height);\n    textFont(Fonts.regular);\n    textSize(16);\n    fill(255);\n    noStroke();\n    textAlign(LEFT, TOP);\n    text(`${nf(game.time.hour, 2, 0)}:${nf(game.time.minute, 2, 0)}`, 820, 20);\n    text(`${game.time.day + 1} ${[\n        \"Spring\",\n        \"Summer\",\n        \"Autumn\",\n        \"Winter\"\n    ][game.time.month]}, Year ${game.time.year}`, 820, 40);\n    text(`${game.people.length} people`, 820, 60);\n    stroke(255);\n    noFill();\n    line(990, 20, 1000, 20);\n    line(990, 100, 1000, 100);\n    line(1000, 20, 1000, 100);\n    const zeroY = map(0, -15, 5, 100, 20);\n    line(990, zeroY, 1000, zeroY);\n    const tempY = map(game.temp, -15, 5, 100, 20);\n    if (tempY > zeroY) fill(0, 0, 255);\n    else fill(255, 0, 0);\n    noStroke();\n    rect(990, tempY, 10, zeroY - tempY);\n    textAlign(RIGHT, TOP);\n    text(`${nf(game.temp, 1, 1)}`, 985, 90);\n    if (mouseIsWithin(0, 0, 800, 800)) {\n        const x = floor(mouseX / 16);\n        const y = floor(mouseY / 16);\n        noFill();\n        stroke(255);\n        rect(x * 16, y * 16, 16, 16);\n        if (game.worldMouseX >= 0 && game.worldMouseY >= 0 && game.worldMouseX < game.world.size && game.worldMouseY < game.world.size) {\n            const item = game.world.get(game.worldMouseX, game.worldMouseY);\n            if (item) {\n                stroke(255);\n                fill(0);\n                rect(810, 120, 200, 300);\n                drawNiceItem(item.item.display, 820, 130, 64);\n                textFont(Fonts.bold);\n                textSize(16);\n                fill(255);\n                textAlign(LEFT, TOP);\n                text(item.item.name, 820, 200);\n                textSize(32);\n                text(item.item.id, 890, 130);\n                textSize(16);\n                const age = game.tick * 60 - item.time;\n                textFont(Fonts.regular);\n                text(`Value: ${item.value}`, 820, 220);\n                text(`Age: ${age / 60} ticks`, 820, 240);\n                const usedIn = item.item.usedIn;\n                const timed = usedIn.find((use)=>use.time);\n                if (timed) {\n                    fill(255);\n                    noStroke();\n                    rect(820, 260, map(age, 0, timed.time, 0, 140), 10);\n                    stroke(255);\n                    noFill();\n                    rect(820, 260, 140, 10);\n                    fill(255);\n                    noStroke();\n                    if (timed.results.length > 2 || timed.results.length === 0) text(\"?\", 970, 255);\n                    else {\n                        const result = Recipe.getResult(item, timed.results[0].origin);\n                        if (result) drawItem(result.item.display, 970, 257);\n                        else text(\"?\", 970, 255);\n                    }\n                }\n                let y = 0;\n                for (const recipe of usedIn){\n                    if (recipe.time) continue;\n                    drawNiceItem(REGISTRY.getItem(recipe.getAnOrigin()).display, 820, 282 + y * 20);\n                    fill(255);\n                    textFont(Fonts.bold);\n                    if (recipe.actor) {\n                        stroke(255);\n                        noFill();\n                        beginShape(LINES);\n                        vertex(837, 290 + y * 20);\n                        vertex(847, 290 + y * 20);\n                        vertex(842, 285 + y * 20);\n                        vertex(842, 295 + y * 20);\n                        endShape();\n                        drawNiceItem(REGISTRY.getItem(recipe.getAnActor()).display, 850, 282 + y * 20);\n                    }\n                    stroke(255);\n                    noFill();\n                    beginShape(LINES);\n                    vertex(870, 290 + y * 20);\n                    vertex(900, 290 + y * 20);\n                    vertex(900, 290 + y * 20);\n                    vertex(895, 295 + y * 20);\n                    vertex(900, 290 + y * 20);\n                    vertex(895, 285 + y * 20);\n                    endShape();\n                    let resIndex = 0;\n                    for (const result of recipe.results){\n                        const originResult = Recipe.getResult(new ItemState(recipe.getAnOrigin()), result.origin);\n                        drawNiceItem(REGISTRY.getItem(originResult ? originResult.item.id : 0).display, 910, 282 + (y + resIndex) * 20);\n                        if (result.actor.type === \"SameItem\" || result.actor.type === \"NewItem\") {\n                            stroke(255);\n                            noFill();\n                            beginShape(LINES);\n                            vertex(927, 290 + y * 20);\n                            vertex(937, 290 + y * 20);\n                            vertex(932, 285 + y * 20);\n                            vertex(932, 295 + y * 20);\n                            endShape();\n                            const actorResult = Recipe.getResult(new ItemState(recipe.getAnActor()), result.actor);\n                            drawNiceItem(REGISTRY.getItem(actorResult ? actorResult.item.id : 0).display, 940, 282 + (y + resIndex) * 20);\n                        }\n                    }\n                    y += recipe.results.length;\n                }\n            } else {\n                stroke(255);\n                fill(0);\n                rect(810, 120, 200, 50);\n                textFont(Fonts.regular);\n                textSize(16);\n                fill(255);\n                textAlign(LEFT, TOP);\n                noStroke();\n                text(\"None\", 820, 135);\n            }\n        }\n        const chunkX = floor(game.worldMouseX / CHUNK_SIZE);\n        const chunkY = floor(game.worldMouseY / CHUNK_SIZE);\n        if (chunkX >= 0 && chunkX < WORLD_SIZE && chunkY >= 0 && chunkY < WORLD_SIZE) {\n            textAlign(RIGHT, TOP);\n            fill(255);\n            textSize(14);\n            textFont(Fonts.bold);\n            const heat = game.world.heat[chunkY * WORLD_SIZE + chunkX];\n            text(\"Heat: \" + nf(heat, 1, 2), 1000, 135);\n            textSize(12);\n            if (heat > game.temp) fill(255, 0, 0);\n            else fill(0, 0, 255);\n            text(nf(heat - game.temp, 1, 2), 1000, 150);\n        }\n    }\n    textSize(16);\n    if (!game.extraInfo) {\n        textFont(Fonts.regular);\n        fill(255);\n        noStroke();\n        textAlign(LEFT, TOP);\n        text(\"Press Q for extra info\", 820, 420);\n        return;\n    }\n    stroke(255);\n    noFill();\n    rect(1020, 10, 200, 200);\n    rect(1020, 220, 200, 200);\n    rect(1020, 430, 510, 370);\n    fill(255);\n    noStroke();\n    textFont(Fonts.bold);\n    textAlign(LEFT, TOP);\n    text(\"Groups\", 1030, 20);\n    text(\"Top\", 1030, 230);\n    text(\"Stats\", 1030, 440);\n    for(let i = 0; i < game.groups.length; i += 1){\n        textAlign(LEFT, TOP);\n        textFont(Fonts.regular);\n        text(game.groups[i], 1030, 40 + i * 20);\n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        text(game.people.reduce((acc, person)=>person.surname === game.groups[i] ? acc + 1 : acc, 0), 1210, 40 + i * 20);\n        if (mouseIsWithin(1030, 40 + i * 20, 180, 20) && input.mouse[LEFT] === 1) jumpToPerson(game.people.find((person)=>person.surname === game.groups[i] && person.id !== game.selectedPerson));\n    }\n    const maxScore = game.people.reduce((acc, person)=>max(acc, person.score), 0);\n    const topScorers = game.people.sort((a, b)=>b.score - a.score).slice(0, 5);\n    for(let i = 0; i < topScorers.length; i += 1){\n        const person = topScorers[i];\n        fill(255);\n        textAlign(LEFT, TOP);\n        textFont(Fonts.regular);\n        textSize(12);\n        text(person.fullName, 1050, 250 + i * 30);\n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        textSize(16);\n        text(Math.round(person.score), 1210, 250 + i * 30);\n        drawNiceItem(person.display, 1030, 250 + i * 30, 16);\n        stroke(255);\n        noFill();\n        rect(1030, 270 + i * 30, 180, 5);\n        noStroke();\n        fill(255);\n        rect(1030, 270 + i * 30, map(person.score, 0, maxScore, 0, 180), 5);\n        if (mouseIsWithin(1030, 250 + i * 30, 180, 20) && input.mouse[LEFT] === 1) jumpToPerson(person);\n    }\n    fill(255);\n    noStroke();\n    textAlign(LEFT, TOP);\n    textSize(16);\n    textFont(Fonts.bold);\n    text(\"Deepest\", 1030, 460);\n    textFont(Fonts.regular);\n    if (game.deepestItemDepth > 0) {\n        drawNiceNoun({\n            type: \"thing\",\n            data: {\n                selector: {\n                    conditions: [\n                        {\n                            type: \"Is\",\n                            data: game.deepestItem\n                        }\n                    ]\n                }\n            }\n        }, 1100, 460);\n        const person = game.people.find((person)=>person.fullName === game.deepestItemCredit);\n        if (person) drawNiceNoun({\n            type: \"person\",\n            data: {\n                id: person.id\n            }\n        }, 1120, 460);\n        else {\n            textFont(Fonts.regular);\n            text(\"dead\", 1080, 460);\n        }\n        textFont(Fonts.bold);\n        fill(255);\n        text(`(${game.deepestItemDepth})`, 1170, 460);\n    } else text(\"none\", 1100, 460);\n    const topCrafters = Object.entries(game.itemsCrafted).sort((a, b)=>b[1] - a[1]).slice(0, 15);\n    const mostCrafted = topCrafters.reduce((acc, [_, count])=>max(acc, count), 0);\n    for(let i = 0; i < topCrafters.length; i += 1){\n        const [id, count] = topCrafters[i];\n        drawNiceNoun({\n            type: \"thing\",\n            data: {\n                selector: {\n                    conditions: [\n                        {\n                            type: \"Is\",\n                            data: +id\n                        }\n                    ]\n                }\n            }\n        }, 1030, 490 + i * 20);\n        fill(255);\n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        textSize(16);\n        text(count, 1210, 490 + i * 20);\n        stroke(255);\n        noFill();\n        rect(1050, 495 + i * 20, 120, 5);\n        noStroke();\n        fill(255);\n        rect(1050, 495 + i * 20, map(count, 0, mostCrafted, 0, 120), 5);\n    }\n    textFont(Fonts.bold);\n    textAlign(LEFT, TOP);\n    text(\"Yummy Foods\", 1230, 460);\n    const topFoods = Object.entries(game.foodEaten).sort((a, b)=>b[1] - a[1]).slice(0, 15);\n    const mostEaten = topFoods.reduce((acc, [_, count])=>max(acc, count), 0);\n    for(let i = 0; i < topFoods.length; i += 1){\n        const [id, count] = topFoods[i];\n        drawNiceNoun({\n            type: \"thing\",\n            data: {\n                selector: {\n                    conditions: [\n                        {\n                            type: \"Is\",\n                            data: +id\n                        }\n                    ]\n                }\n            }\n        }, 1230, 490 + i * 20);\n        fill(255);\n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        textSize(16);\n        text(count, 1410, 490 + i * 20);\n        stroke(255);\n        noFill();\n        rect(1250, 495 + i * 20, 120, 5);\n        noStroke();\n        fill(255);\n        rect(1250, 495 + i * 20, map(count, 0, mostEaten, 0, 120), 5);\n    }\n    const selected = game.people.find((person)=>person.id === game.selectedPerson);\n    if (selected) {\n        // draw view rectangle\n        fill(255, 10);\n        noStroke();\n        rect(selected.x * 16 - game.camera.x * 16 - 144, selected.y * 16 - game.camera.y * 16 - 144, 304, 304);\n        if (selected.short[\"goto\"] != null) {\n            stroke(255);\n            noFill();\n            ellipse((selected.short[\"goto\"].x - game.camera.x) * 16 + 8, (selected.short[\"goto\"].y - game.camera.y) * 16 + 8, 4, 4);\n        }\n        stroke(255);\n        fill(0);\n        rect(810, 430, 200, 300);\n        noStroke();\n        fill(255);\n        drawNiceItem(selected.display, 820, 440, 64);\n        textFont(Fonts.bold);\n        textSize(16);\n        fill(255);\n        textAlign(LEFT, TOP);\n        text(selected.name, 890, 440);\n        fill(COLORS[selected.color]);\n        text(selected.surname, 890, 460);\n        textFont(Fonts.regular);\n        fill(255);\n        text(`Age: ${nf((game.tick - selected.born) / 4 / 30 / 24 / 60, 0, 4)} years`, 820, 510);\n        fill(150, 0, 0);\n        rect(820, 540, map(selected.health, 0, 100, 0, 140), 10);\n        text(Math.round(selected.health), 970, 535);\n        stroke(255);\n        noFill();\n        rect(820, 540, 140, 10);\n        noStroke();\n        fill(0, 150, 0);\n        rect(820, 560, map(selected.hunger, 0, 100, 0, 140), 10);\n        text(Math.round(selected.hunger), 970, 555);\n        stroke(255);\n        noFill();\n        rect(820, 560, 140, 10);\n        noStroke();\n        fill(0, 0, 200);\n        rect(820, 580, 30, 10);\n        fill(0, 0, 100);\n        rect(850, 580, 30, 10);\n        fill(100, 0, 0);\n        rect(900, 580, 30, 10);\n        fill(200, 0, 0);\n        rect(930, 580, 30, 10);\n        stroke(255);\n        noFill();\n        rect(820, 580, 140, 10);\n        let tempX = map(selected.temperature, -15, 15, 0, 1);\n        noFill();\n        stroke(tempX * 255, 0, tempX * -255 + 255);\n        line(820 + tempX * 140, 580, 820 + tempX * 140, 590);\n        triangle(820 + tempX * 140 - 5, 595, 820 + tempX * 140 + 5, 595, 820 + tempX * 140, 590);\n        noStroke();\n        fill(tempX * 255, 0, tempX * -255 + 255);\n        text(Math.round(selected.temperature * 10) / 10, 970, 575);\n        stroke(255);\n        noFill();\n        rect(820, 600, 140, 10);\n        noStroke();\n        colorMode(HSB, 255);\n        fill(millis() / 10 % 255, 255, 255);\n        text(Math.round(selected.score), 970, 595);\n        rect(820, 600, map(selected.score, 0, maxScore, 0, 140), 10);\n        colorMode(RGB);\n        stroke(255);\n        noFill();\n        rect(820, 620, 140, 10);\n        const totalNeeds = Object.values(selected.needs).reduce((acc, need)=>acc + need, 0);\n        let x = 0;\n        for(const need in selected.needs){\n            const w = map(selected.needs[need], 0, totalNeeds, 0, 140);\n            switch(need){\n                case \"hunger\":\n                    fill(0, 150, 0);\n                    break;\n                case \"temperature\":\n                    fill(0, 0, 200);\n                    break;\n                case \"health\":\n                    fill(150, 0, 0);\n                    break;\n                case \"boredom\":\n                    fill(100);\n                    break;\n            }\n            rect(820 + x, 620, w, 10);\n            x += w;\n        }\n        stroke(255);\n        fill(0);\n        rect(1230, 10, 300, 410);\n        textFont(Fonts.bold);\n        textSize(16);\n        fill(255);\n        noStroke();\n        textAlign(LEFT, TOP);\n        text(\"Objectives\", 1240, 20);\n        let y = 0;\n        for (const objective of selected.objectives){\n            textAlign(LEFT, TOP);\n            drawObjective(objective, 1250, 40 + y * 20);\n            stroke(100);\n            noFill();\n            const children = objective.type === \"obtain\" ? objective.data.children : [];\n            for (const child of children){\n                const y2 = child;\n                const mid = (y + y2) / 2;\n                const diff = y2 - y - 1;\n                bezier(1245, 50 + y * 20, 1240 - diff * 5, 50 + mid * 20, 1240 - diff * 5, 50 + mid * 20, 1245, 50 + y2 * 20);\n            }\n            y += 1;\n            if (y >= 20) break;\n        }\n    } else {\n        stroke(255);\n        fill(0);\n        rect(810, 430, 200, 50);\n        noStroke();\n        fill(255);\n        textFont(Fonts.regular);\n        textSize(16);\n        textAlign(LEFT, TOP);\n        text(\"None\", 820, 445);\n    }\n}\n\n//# sourceMappingURL=index.3f4a4b5a.js.map\n","const input = { keys: {}, mouse: {} }\nconst game = {};\n\nconst CP_437 = [\n    ' ', '☺', '☻', '♥', '♦', '♣', '♠', '•', '◘', '○', '◙', '♂', '♀', '♪', '♫', '☼',\n    '►', '◄', '↕', '‼', '¶', '§', '▬', '↨', '↑', '↓', '→', '←', '∟', '↔', '▲', '▼',\n    ' ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.', '/',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',\n    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\\\', ']', '^', '_',\n    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '⌂',\n    'Ç', 'ü', 'é', 'â', 'ä', 'à', 'å', 'ç', 'ê', 'ë', 'è', 'ï', 'î', 'ì', 'Ä', 'Å',\n    'É', 'æ', 'Æ', 'ô', 'ö', 'ò', 'û', 'ù', 'ÿ', 'Ö', 'Ü', '¢', '£', '¥', '₧', 'ƒ',\n    'á', 'í', 'ó', 'ú', 'ñ', 'Ñ', 'ª', 'º', '¿', '⌐', '¬', '½', '¼', '¡', '«', '»',\n    '░', '▒', '▓', '│', '┤', '╡', '╢', '╖', '╕', '╣', '║', '╗', '╝', '╜', '╛', '┐',\n    '└', '┴', '┬', '├', '─', '┼', '╞', '╟', '╚', '╔', '╩', '╦', '╠', '═', '╬', '╧',\n    '╨', '╤', '╥', '╙', '╘', '╒', '╓', '╫', '╪', '┘', '┌', '█', '▄', '▌', '▐', '▀',\n    'α', 'ß', 'Γ', 'π', 'Σ', 'σ', 'µ', 'τ', 'Φ', 'Θ', 'Ω', 'δ', '∞', 'φ', 'ε', '∩',\n    '≡', '±', '≥', '≤', '⌠', '⌡', '÷', '≈', '°', '∙', '·', '√', 'ⁿ', '²', '■', ' '\n];\nconst COLORS = ['#ff0040', '#131313', '#1b1b1b', '#272727', '#3d3d3d', '#5d5d5d', '#858585', '#b4b4b4', '#ffffff', '#c7cfdd', '#92a1b9', '#657392', '#424c6e', '#2a2f4e', '#1a1932', '#0e071b', '#1c121c', '#391f21', '#5d2c28', '#8a4836', '#bf6f4a', '#e69c69', '#f6ca9f', '#f9e6cf', '#edab50', '#e07438', '#c64524', '#8e251d', '#ff5000', '#ed7614', '#ffa214', '#ffc825', '#ffeb57', '#d3fc7e', '#99e65f', '#5ac54f', '#33984b', '#1e6f50', '#134c4c', '#0c2e44', '#00396d', '#0069aa', '#0098dc', '#00cdf9', '#0cf1ff', '#94fdff', '#fdd2ed', '#f389f5', '#db3ffd', '#7a09fa', '#3003d9', '#0c0293', '#03193f', '#3b1443', '#622461', '#93388f', '#ca52c9', '#c85086', '#f68187', '#f5555d', '#ea323c', '#c42430', '#891e2b', '#571c27'];\nlet Fonts = {};\nlet tick = 0;\n\nconst EDITOR = false || new URLSearchParams(window.location.search).get('editor') != null;\n\nfunction preload() {\n    Fonts = {\n        pixel: loadFont('./static/font/PxPlus_IBM_EGA_8x8.ttf'),\n        regular: loadFont('./static/font/LibreFranklin-Regular.ttf'),\n        bold: loadFont('./static/font/LibreFranklin-Bold.ttf'),\n    }\n}\n\nfunction setup() {\n    createCanvas();\n    windowResized();\n    textFont(Fonts.pixel);\n    textSize(16);\n\n    if (EDITOR) {\n        document.getElementById('editor').style.display = 'block';\n    }\n    game.world = new World();\n\n    const naturalItems = REGISTRY.items.filter(item => item.tags.includes('natural')).map(item => item.id);\n    const totalWeight = naturalItems.reduce((acc, id) => acc + (REGISTRY.getItem(id).properties.weight ?? 1), 0);\n\n    for (let i = 0; i < game.world.size * game.world.size / 16; i += 1) {\n        const x = floor(random(game.world.size));\n        const y = floor(random(game.world.size));\n        if (x < 4 || x > game.world.size - 4 || y < 4 || y > game.world.size - 4) {\n            continue;\n        }\n        const w = random(totalWeight);\n        let acc = 0;\n        let item = null;\n        for (const id of naturalItems) {\n            acc += REGISTRY.getItem(id).properties.weight ?? 1;\n            if (acc >= w) {\n                item = id;\n                break;\n            }\n        }\n        item = item || naturalItems[naturalItems.length - 1];\n        game.world.set(x, y, new ItemState(item));\n    }\n\n    game.world.set(floor(game.world.size / 2), floor(game.world.size) / 2, new ItemState(57));\n    game.camera = { x: 0, y: 0 };\n\n    game.people = [];\n    game.groups = [];\n    for (let i = 0; i < 5; i += 1) {\n        const group = generateGroup(0, game.world);\n        game.groups.push(group[0].surname);\n        game.people.push(...group);\n    }\n    assignReputations(game.people);\n    game.acc = 0;\n\n    game.worldMouseX = 0;\n    game.worldMouseX = 0;\n    game.mouseIndex = 0;\n    game.tick = 0;\n\n    game.selectedPerson = '';\n\n    game.peopleGraph = new Array(50).fill(game.people.length);\n\n    game.itemsCrafted = {};\n    game.foodEaten = {};\n    game.deepestItem = 0;\n    game.deepestItemDepth = 0;\n    game.deepestItemCredit = '';\n\n    game.skip = 0;\n    game.temp = 0;\n\n    game.extraInfo = false;\n    game.renderData = {};\n\n    // game.people = [ game.people[0] ];\n    // game.people[0].x = 49;\n    // game.people[0].y = 49;\n}\n\nfunction windowResized() {\n    resizeCanvas(windowWidth, windowHeight);\n}\n\nfunction keyPressed() {\n    input.keys[keyCode] = 0;\n}\n\nfunction keyReleased() {\n    input.keys[keyCode] = -1;\n}\n\nfunction mousePressed() {\n    input.mouse[mouseButton] = 0;\n}\n\nfunction mouseReleased() {\n    input.mouse[mouseButton] = -1;\n}\n\nfunction updateInput() {\n    for (let key in input.keys) {\n        if (input.keys[key] >= 0) {\n            input.keys[key] += 1;\n        }\n    }\n    for (let button in input.mouse) {\n        if (input.mouse[button] >= 0) {\n            input.mouse[button] += 1;\n        }\n    }\n}\n\nfunction isWithin(tx, ty, x, y, w, h) {\n    return tx >= x && tx <= x + w && ty >= y && ty <= y + h;\n}\n\nfunction mouseIsWithin(x, y, w, h) {\n    return isWithin(mouseX, mouseY, x, y, w, h);\n}\n\nfunction runTick() {\n\n    game.temp = sin(game.tick / (60 * 24 * 30 * 4) * TWO_PI) * 10 - 5 - cos(game.tick / (60 * 24) * TWO_PI) * 2;\n    game.world.update(game.temp);\n\n    for (const { item, x, y } of game.world.active()) {\n        const timed = item.item.usedIn.find(use => use.time);\n        if (timed) {\n            if (timed.willOccur(item, null, game.tick * 60)) {\n                console.log('occured');\n                const [ result ] = timed.getResults(item, null, Math.random());\n                result.time = game.tick * 60;\n                game.world.set(x, y, result);\n                freeChunk(floor(x / CHUNK_SIZE) + floor(y / CHUNK_SIZE) * WORLD_SIZE);\n            }\n        }\n    }\n    for (const person of game.people) {\n        person.update(game.world, game.temp);\n    }\n    for (const person of game.people) {\n        if (person.health <= 0) {\n            game.world.set(person.x, person.y, new ItemState(86)); // grave\n            freeChunk(floor(person.x / CHUNK_SIZE) + floor(person.y / CHUNK_SIZE) * WORLD_SIZE);\n        }\n    }\n    game.people = game.people.filter(person => person.health > 0);\n    for (const person of game.people) {\n        person.think(game.world, game.people, game.tick * 60);\n    }\n    let actions = {};\n    for (const person of game.people) {\n        const action = person.act();\n        if (action) {\n            actions[person.id] = action;\n        }\n    }\n    for (const person of game.people) {\n        const action = actions[person.id];\n        if (action.type === 'move') {\n            const newX = person.x + (action.data.direction === 4 ? 1 : 0) + (action.data.direction === 2 ? -1 : 0);\n            const newY = person.y + (action.data.direction === 3 ? 1 : 0) + (action.data.direction === 1 ? -1 : 0);\n            if (newX < 0 || newX >= game.world.size || newY < 0 || newY >= game.world.size) {\n                continue;\n            }\n            if (game.world.get(newX, newY) && game.world.get(newX, newY).item.tags.includes('blocking')) {\n                continue;\n            }\n            if (game.people.find(p => p.x === newX && p.y === newY)) {\n                continue;\n            }\n            person.x = newX;\n            person.y = newY;\n        } else if (action.type === 'eat') {\n            if (person.holding != null) {\n                const item = person.holding.item;\n                if (item.tags.includes('edible')) {\n                    game.foodEaten[item.id] = (game.foodEaten[item.id] || 0) + 1;\n                    person.hunger += item.properties['food'] || 0;\n                    person.score += item.properties['food'] || 0;\n                    person.holding = item.properties['leftovers'] ? new ItemState(item.properties['leftovers']) : null;\n                }\n            }\n        } else if (action.type === 'interact') {\n            const prev = game.world.get(person.x, person.y);\n            let intX = person.x + (action.data.direction === 4 ? 1 : 0) + (action.data.direction === 2 ? -1 : 0);\n            let intY = person.y + (action.data.direction === 3 ? 1 : 0) + (action.data.direction === 1 ? -1 : 0);\n            if (person.holding === null && game.world.get(intX, intY) != null) {\n                const item = game.world.get(intX, intY).item;\n                if (!item.tags.includes('static')) {\n                    person.holding = game.world.get(intX, intY);\n                    game.world.set(intX, intY, null);\n                    freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n\n                } else if (item.usedIn.find(use => !use.actor)) {\n                    const recipe = item.usedIn.find(use => !use.actor);\n                    const [origin, actor] = recipe.getResults(game.world.get(intX, intY), null, Math.random());\n                    game.world.set(intX, intY, origin);\n                    freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n\n                    person.holding = actor;\n                    if (game.world.get(intX, intY)) {\n                        game.world.get(intX, intY).time = game.tick * 60;\n                        if (prev && origin.id !== prev.id) {\n                            person.addItemToMemory(game.world, intX, intY, game.tick * 60);\n                        }\n                    }\n                }\n            } else if (person.holding != null && game.world.get(intX, intY) == null) {\n                game.world.set(intX, intY, person.holding);\n                freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n\n                game.world.get(intX, intY).time = game.tick * 60;\n                person.holding = null;\n            } else if (person.holding != null && game.world.get(intX, intY) != null) {\n                const item = game.world.get(intX, intY).item;\n                for (const recipe of item.usedIn) {\n                    if (recipe.willOccur(game.world.get(intX, intY), person.holding, game.tick * 60)) {\n                        const [origin, actor] = recipe.getResults(game.world.get(intX, intY), person.holding, Math.random());\n                        game.world.set(intX, intY, origin);\n                        freeChunk(floor(intX / CHUNK_SIZE) + floor(intY / CHUNK_SIZE) * WORLD_SIZE);\n\n                        person.holding = actor;\n                        if (game.world.get(intX, intY)) {\n                            game.world.get(intX, intY).time = game.tick * 60;\n                            if (prev && origin.id !== prev.id) {\n                                person.addItemToMemory(game.world, intX, intY, game.tick * 60);\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n\n            const runChecks = (item) => {\n                if (item.item.tags.includes('important')) {\n                    person.score += (item.item.depth() ** 2) * 10; \n                }\n                console.log(item.item.name, item.item.depth());\n                if (item.item.depth() > game.deepestItemDepth) {\n                    game.deepestItem = item.id;\n                    game.deepestItemDepth = item.item.depth();\n                    game.deepestItemCredit = person.fullName;\n                }\n                game.itemsCrafted[item.item.id] = (game.itemsCrafted[item.item.id] || 0) + 1;\n            }\n\n            game.world.get(intX, intY) && game.world.get(intX, intY).id !== 0 && runChecks(game.world.get(intX, intY));\n            person.holding && person.holding.id !== 0 && runChecks(person.holding);\n\n        }\n    }\n    game.tick += 1;\n\n    if (game.tick % 60 === 0) {\n        game.peopleGraph.shift();\n        game.peopleGraph.push(game.people.length);\n    }\n}\n\nfunction update() {\n\n    game.time = {\n        minute: game.tick % 60,\n        hour: floor(game.tick / 60) % 24,\n        day: floor(game.tick / 60 / 24) % 30,\n        month: floor(game.tick / 60 / 24 / 30) % 4,\n        year: floor(game.tick / 60 / 24 / 30 / 4) + 1000,\n    }\n\n    if (mouseIsWithin(0, 0, 50 * 16, 50 * 16)) {\n        game.worldMouseX = floor(mouseX / 16) + game.camera.x;\n        game.worldMouseY = floor(mouseY / 16) + game.camera.y;\n    }\n    \n    if (input.keys[LEFT_ARROW] > 0) {\n        game.camera.x -= 1;\n    }\n    if (input.keys[RIGHT_ARROW] > 0) {\n        game.camera.x += 1;\n    }\n    if (input.keys[UP_ARROW] > 0) {\n        game.camera.y -= 1;\n    }\n    if (input.keys[DOWN_ARROW] > 0) {\n        game.camera.y += 1;\n    }\n\n    if (input.keys['Q'.charCodeAt(0)] === 1) {\n        game.extraInfo = !game.extraInfo;\n    }\n\n\n    if (input.keys['P'.charCodeAt(0)] > 0) {\n        game.skip = 1440; // skip ahead 1 day\n    }\n\n    if (input.keys['O'.charCodeAt(0)] > 0) {\n        game.skip = 1440 * 7; // skip ahead 1 week\n    }\n\n    if (input.keys['I'.charCodeAt(0)] > 0) {\n        game.skip = 1440 * 30; // skip ahead 1 month\n    }\n\n    if (input.keys['U'.charCodeAt(0)] > 0) {\n        game.skip = 1440 * 30 * 4; // skip ahead 1 year\n    }\n\n    if (game.skip > 0) {\n        const start = millis();\n        let i = 0;\n        while (game.skip > 0 && millis() - start < 100) {\n            runTick();\n            game.skip -= 1;\n            i += 1;\n        }\n        game.tps = i / ((millis() - start) / 1000);\n        return;\n    }\n\n    let dt = frameRate() > 0 ? 1 / frameRate() : 0;\n    game.acc += dt * 2 * (input.keys['T'.charCodeAt(0)] > 0 ? 100 : 1);\n    game.acc = min(game.acc, 200);\n    while (game.acc > 1) {\n        game.acc -= 1;\n        runTick();\n    }\n\n    for (const person of game.people) {\n        if (mouseIsWithin(0, 0, 50 * 16, 50 * 16)) {\n            if (person.x === game.worldMouseX && person.y === game.worldMouseY) {\n                game.selectedPerson = person.id;\n            }\n        }\n    }\n}\n\nfunction drawItem(display, x, y, to = window) {\n    if (display.length === 0) {\n        return;\n    }\n    const disp = display[tick % display.length];\n    const { character, color } = disp;\n    to.fill(COLORS[color]);\n    to.textFont(Fonts.pixel);\n    to.text(CP_437[character], x, y);\n}\n\nfunction drawNiceItem(display, x, y, size = 16) {\n    textAlign(LEFT, TOP);\n    textSize(size);\n    stroke(30);\n    fill(20);\n    rect(x, y, size, size);\n    noStroke();\n    drawItem(display, x, y);\n}\n\nfunction drawNiceNoun(noun, x, y, size = 16) {\n    let message = '';\n    textAlign(LEFT, TOP);\n    switch (noun.type) {\n        case 'person':\n            const person = game.people.find(person => person.id === noun.data.id);\n            drawNiceItem((person || REGISTRY.getItem(86)).display, x, y, size);\n            message = person ? person.fullName : 'dead';\n            break;\n        case 'place':\n            stroke(30);\n            fill(20);\n            rect(x, y, size, size);\n            noFill();\n            stroke(255);\n            const miniX = x + map(noun.data.x, 0, game.world.size, 0, size);\n            const miniY = y + map(noun.data.y, 0, game.world.size, 0, size);\n            line(miniX - 1, miniY - 1, miniX + 1, miniY + 1);\n            line(miniX - 1, miniY + 1, miniX + 1, miniY - 1);\n            message = `${noun.data.x}, ${noun.data.y}`;\n            break;\n        case 'thing':\n            const query = REGISTRY.query(noun.data.selector);\n            let display = query.map(id => REGISTRY.getItem(id).display).flat();\n            if (display.length === 0) {\n                display = REGISTRY.getItem(0).display;\n            }\n            drawNiceItem(display, x, y, size);\n            message = query.map(id => REGISTRY.getItem(id).name).join(', ');\n            break;\n        }\n\n    if (mouseIsWithin(x, y, size, size)) {\n        textFont(Fonts.regular);\n        const w = min(textWidth(message), 300);\n        textAlign(CENTER, BOTTOM);\n        textSize(16);\n        \n        stroke(255);\n        fill(0);\n        rect(x - w / 2 - 10, y - 50, w + 20, 40);\n        fill(255);\n        noStroke();\n        text(message, x, y - 20);\n        textAlign(LEFT, TOP);\n    }\n}\n    \n\nfunction drawMemory(memory, x, y) {\n    noStroke();\n    switch (memory.type) {\n        case 'exists':\n            drawNiceNoun(memory.data.noun, x, y);\n            textFont(Fonts.regular);\n            fill(255);\n            text('exists', x + 20, y);\n            break;\n        case 'location':\n            drawNiceNoun(memory.data.noun, x, y);\n            textFont(Fonts.regular);\n            fill(255);\n            text('is at', x + 20, y);\n            drawNiceNoun({ type: 'place', data: { x: memory.data.x, y: memory.data.y }}, x + 55, y);\n            break;\n        case 'personKnows':\n            drawNiceNoun(memory.data.person, x, y);\n            textFont(Fonts.regular);\n            fill(255);\n            text('knows', x + 20, y);\n            drawMemory(memory.data.memory, x + 50, y);\n            break;\n    }\n}\n\nfunction drawObjective(objective, x, y) {\n    noStroke();\n    textAlign(LEFT, TOP);\n    textSize(16);\n    textFont(Fonts.regular);\n    fill(255);\n    switch (objective.type) {\n        case 'fulfillNeed':\n            text(objective.data.need, x, y);\n            break;\n        case 'obtain':\n            text('obtain', x, y);\n            drawNiceNoun(objective.data.noun, x + 60, y);\n            if (objective.data.another) {\n                textFont(Fonts.bold);\n                text('(another)', x + 80, y);\n            }\n            break;\n    }\n}\n\nfunction jumpToPerson(person) {\n    game.camera.x = person.x - 25;\n    game.camera.y = person.y - 25;\n    game.selectedPerson = person.id;\n}\n\nfunction freeChunk(index) {\n    if (game.renderData[index]) {\n        game.renderData[index].static.remove();\n        delete game.renderData[index];\n    }\n}\n\nfunction drawStaticChunk(chunk) {\n    const graphics = createGraphics(CHUNK_SIZE * 16, CHUNK_SIZE * 16);\n    graphics.textSize(16);\n    graphics.textAlign(LEFT, TOP);\n    for (let x = 0; x < CHUNK_SIZE; x += 1) {\n        for (let y = 0; y < CHUNK_SIZE; y += 1) {\n            const item = chunk.items[x + y * CHUNK_SIZE];\n            if (item && item.item.display.length === 1) {\n                drawItem(item.item.display, x * 16, y * 16, graphics);\n            }\n        }\n    }\n    return graphics;\n}\n\nfunction mod(n, m) {\n    return ((n % m) + m) % m;\n}\n\nfunction draw() {\n    tick = floor(millis() / 500);\n    if (EDITOR) {\n        updateInput();\n        drawEditor();\n        return;\n    }\n    update();\n    updateInput();\n    background(0);\n    textSize(16);\n\n\n    fill(255);\n    textAlign(LEFT, TOP);\n    textFont(Fonts.regular);\n    if (game.skip > 0) {\n        text('Skipping ahead... ticks: ' + game.skip, 10, 10);\n        text('tps: ' + game.tps, 10, 30);\n        text('people left: ' + game.people.length, 10, 50);\n        if (input.keys[ESCAPE] > 0) {\n            game.skip = 0;\n        }\n        return;\n    }\n\n    noStroke();\n    fill(10);\n    rect(0, 0, 50 * 16, 50 * 16);\n    fill(10);\n    textAlign(LEFT, TOP);\n    \n    for (let x = 0; x < 50; x += 1) {\n        for (let y = 0; y < 50; y += 1) {\n            const cx = x + game.camera.x;\n            const cy = y + game.camera.y;\n            if (cx < 0 || cx >= game.world.size || cy < 0 || cy >= game.world.size) {\n                continue;\n            }\n            const item = game.world.get(cx, cy);\n            if (item != null && item.item.tags.includes('heatSource')) {\n                stroke(255, 63, 0, 200);\n                fill(255, 63, 0, 40);\n                noStroke();\n                ellipse((x + 0.5) * 16, (y + 0.5) * 16, 16 * item.item.properties.heat, 16 * item.item.properties.heat);\n            }\n        }\n    }\n    \n    stroke(30);\n    beginShape(LINES);\n    for (let i = 0; i < 50; i += 1) {\n        if (i + game.camera.x >= 0 && i + game.camera.x <= game.world.size) {\n            vertex(i * 16, 0);\n            vertex(i * 16, 50 * 16);\n        }\n        if (i + game.camera.y >= 0 && i + game.camera.y <= game.world.size) {\n            vertex(0, i * 16);\n            vertex(50 * 16, i * 16);\n        }\n    }\n    stroke(50);\n    for (let i = 0; i < 50; i += 1) {\n        if ((i + game.camera.x) % 10 === 0 && (i + game.camera.x >= 0 && i + game.camera.x <= game.world.size)) {\n            vertex(i * 16, 0);\n            vertex(i * 16, 50 * 16);\n        }\n        if ((i + game.camera.y) % 10 === 0 && i + game.camera.y >= 0 && i + game.camera.y <= game.world.size) {\n            vertex(0, i * 16);\n            vertex(50 * 16, i * 16);\n        }\n    }\n    endShape();\n    noFill();\n    rect(0, 0, 50 * 16, 50 * 16);\n    for (let x = 0; x <= 50 / CHUNK_SIZE; x += 1) {\n        for (let y = 0; y <= 50 / CHUNK_SIZE; y += 1) {\n            const cx = x + floor(game.camera.x / CHUNK_SIZE);\n            const cy = y + floor(game.camera.y / CHUNK_SIZE);\n            if (cx < 0 || cx >= WORLD_SIZE || cy < 0 || cy >= WORLD_SIZE) {\n                continue;\n            }\n            const index = cx + cy * WORLD_SIZE;\n\n            if (!game.renderData[index]) {\n                game.renderData[index] = { \n                    static: drawStaticChunk(game.world.chunks[index]), \n                    dynamic: Object.entries(game.world.chunks[index].items)\n                        .filter(([i, item]) => item && item.item.display.length > 1)\n                        .map(([i, item]) => ({ x: (i % CHUNK_SIZE) * 16, y: floor(i / CHUNK_SIZE) * 16, item }))\n                    };\n            }\n\n            if (game.renderData[index]) {\n                image(game.renderData[index].static, x * CHUNK_SIZE * 16 - mod(game.camera.x, CHUNK_SIZE) * 16, y * CHUNK_SIZE * 16 - mod(game.camera.y, CHUNK_SIZE) * 16);\n                noStroke();\n                for (const { x: dx, y: dy, item } of game.renderData[index].dynamic) {\n                    drawItem(item.item.display, x * CHUNK_SIZE * 16 - mod(game.camera.x, CHUNK_SIZE) * 16 + dx, y * CHUNK_SIZE * 16 - mod(game.camera.y, CHUNK_SIZE) * 16 + dy);\n                }\n            }\n        }\n    }\n\n    for (const index in game.renderData) {\n        const x = index % WORLD_SIZE;\n        const y = floor(index / WORLD_SIZE);\n\n        if (x < floor(game.camera.x / CHUNK_SIZE) - 4 || x > floor((game.camera.x + 50) / CHUNK_SIZE) + 4 || y < floor(game.camera.y / CHUNK_SIZE) - 4 || y > floor((game.camera.y + 50) / CHUNK_SIZE) + 4) {\n            freeChunk(index);\n        }\n    }\n\n    for (const person of game.people) {\n        if (person.x > game.camera.x && person.x < game.camera.x + 50 && person.y > game.camera.y && person.y < game.camera.y + 50) {\n            noFill();\n            stroke(COLORS[person.altColor]);\n            rect((person.x - game.camera.x) * 16  - 2, (person.y - game.camera.y) * 16 - 2, 20, 20);\n            noStroke();\n            drawItem(person.display, (person.x - game.camera.x) * 16, (person.y - game.camera.y) * 16);\n        }\n    }\n\n    stroke(255);\n    fill(0);\n    rect(50 * 16 + 10, 10, 200, 100);\n\n    stroke(100);\n    noFill();\n    beginShape();\n    const peopleGraphMax = max(...game.peopleGraph);\n    for (let i = 0; i < game.peopleGraph.length; i += 1) {\n        const x = 50 * 16 + 20 + map(i, 0, game.peopleGraph.length - 1, 0, 100);\n        const y = 110 - map(game.peopleGraph[i], 0, peopleGraphMax, 0, 30);\n        vertex(x, y);\n    }\n    endShape();\n\n    noStroke();\n    fill(0);\n    rect(0, 50 * 16, width, height - 50 * 16);\n    rect(50 * 16, 0, width - 50 * 16, height);\n\n\n    textFont(Fonts.regular);\n    textSize(16);\n    fill(255);\n    noStroke();\n    textAlign(LEFT, TOP);\n    text(`${nf(game.time.hour, 2, 0)}:${nf(game.time.minute, 2, 0)}`, 50 * 16 + 20, 20);\n    text(`${game.time.day + 1} ${['Spring', 'Summer', 'Autumn', 'Winter'][game.time.month]}, Year ${game.time.year}`, 50 * 16 + 20, 40);\n    text(`${game.people.length} people`, 50 * 16 + 20, 60);\n\n    stroke(255);\n    noFill();\n    line(50 * 16 + 190, 20, 50 * 16 + 200, 20);\n    line(50 * 16 + 190, 100, 50 * 16 + 200, 100);\n    line(50 * 16 + 200, 20, 50 * 16 + 200, 100);\n    const zeroY = map(0, -15, 5, 100, 20);\n    line(50 * 16 + 190, zeroY, 50 * 16 + 200, zeroY);\n    const tempY = map(game.temp, -15, 5, 100, 20);\n    if (tempY > zeroY) {\n        fill(0, 0, 255);\n    } else {\n        fill(255, 0, 0);\n    }\n    noStroke();\n    rect(50 * 16 + 190, tempY, 10, zeroY - tempY);\n    textAlign(RIGHT, TOP);\n    text(`${nf(game.temp, 1, 1)}`, 50 * 16 + 185, 90);\n\n\n    if (mouseIsWithin(0, 0, 50 * 16, 50 * 16)) {\n        const x = floor(mouseX / 16);\n        const y = floor(mouseY / 16);\n        noFill();\n        stroke(255);\n        rect(x * 16, y * 16, 16, 16);\n        if (game.worldMouseX >= 0 && game.worldMouseY >= 0 && game.worldMouseX < game.world.size && game.worldMouseY < game.world.size) {\n            const item = game.world.get(game.worldMouseX, game.worldMouseY);\n            if (item) {\n                \n                stroke(255);\n                fill(0);\n                rect(50 * 16 + 10, 120, 200, 300);\n\n                drawNiceItem(item.item.display, 50 * 16 + 20, 130, 64);\n\n                textFont(Fonts.bold);\n                textSize(16);\n                fill(255);\n                textAlign(LEFT, TOP);\n                text(item.item.name, 50 * 16 + 20, 200);\n                textSize(32);\n                text(item.item.id, 50 * 16 + 90, 130)\n\n                textSize(16);\n                const age = game.tick * 60 - item.time;\n                textFont(Fonts.regular);\n                text(`Value: ${item.value}`, 50 * 16 + 20, 220);\n                text(`Age: ${age / 60} ticks`, 50 * 16 + 20, 240);\n                \n                const usedIn = item.item.usedIn;\n                const timed = usedIn.find(use => use.time);\n                if (timed) {\n                    fill(255);\n                    noStroke();\n                    rect(50 * 16 + 20, 260, map(age, 0, timed.time, 0, 140), 10);\n                    stroke(255);\n                    noFill();\n                    rect(50 * 16 + 20, 260, 140, 10);\n                    \n                    fill(255);\n                    noStroke();\n                    if (timed.results.length > 2 || timed.results.length === 0) {\n                        text('?', 50 * 16 + 170, 255);\n                    } else {\n                        const result = Recipe.getResult(item, timed.results[0].origin);\n                        if (result) {\n                            drawItem(result.item.display, 50 * 16 + 170, 257);\n                        } else { \n                            text('?', 50 * 16 + 170, 255);\n                        }\n                    }\n                }\n\n                let y = 0;\n                \n                for (const recipe of usedIn) {\n                    if (recipe.time) {\n                        continue;\n                    }\n                    \n                    drawNiceItem(REGISTRY.getItem(recipe.getAnOrigin()).display, 50 * 16 + 20, 282 + y * 20);\n\n                    fill(255);\n                    textFont(Fonts.bold);\n                    if (recipe.actor) {\n                        stroke(255);\n                        noFill();\n                        beginShape(LINES);\n                        vertex(50 * 16 + 37, 290 + y * 20);\n                        vertex(50 * 16 + 47, 290 + y * 20);\n                        vertex(50 * 16 + 42, 285 + y * 20);\n                        vertex(50 * 16 + 42, 295 + y * 20);\n                        endShape();\n                        \n                        drawNiceItem(REGISTRY.getItem(recipe.getAnActor()).display, 50 * 16 + 50, 282 + y * 20);\n                    }\n\n                    stroke(255);\n                    noFill();\n                    beginShape(LINES);\n                    vertex(50 * 16 + 70, 290 + y * 20);\n                    vertex(50 * 16 + 100, 290 + y * 20);\n                    vertex(50 * 16 + 100, 290 + y * 20);\n                    vertex(50 * 16 + 95, 295 + y * 20);\n                    vertex(50 * 16 + 100, 290 + y * 20);\n                    vertex(50 * 16 + 95, 285 + y * 20);\n                    endShape();\n\n                    let resIndex = 0;\n                    for (const result of recipe.results) {\n                        const originResult = Recipe.getResult(new ItemState(recipe.getAnOrigin()), result.origin);\n                        drawNiceItem(REGISTRY.getItem(originResult ? originResult.item.id : 0).display, 50 * 16 + 110, 282 + (y + resIndex) * 20);\n                        if (result.actor.type === 'SameItem' || result.actor.type === 'NewItem') {\n                            stroke(255);\n                            noFill();\n                            beginShape(LINES);\n                            vertex(50 * 16 + 127, 290 + y * 20);\n                            vertex(50 * 16 + 137, 290 + y * 20);\n                            vertex(50 * 16 + 132, 285 + y * 20);\n                            vertex(50 * 16 + 132, 295 + y * 20);\n                            endShape();\n\n                            const actorResult = Recipe.getResult(new ItemState(recipe.getAnActor()), result.actor);\n                            drawNiceItem(REGISTRY.getItem(actorResult ? actorResult.item.id : 0).display, 50 * 16 + 140, 282 + (y + resIndex) * 20);\n                        }\n                    }\n\n                    y += recipe.results.length;\n\n                }\n                \n\n            } else {\n                stroke(255);\n                fill(0);\n                rect(50 * 16 + 10, 120, 200, 50);\n                textFont(Fonts.regular);\n                textSize(16);\n                fill(255);\n                textAlign(LEFT, TOP);\n                noStroke();\n                text('None', 50 * 16 + 20, 135);\n            }\n\n        }\n\n        const chunkX = floor(game.worldMouseX / CHUNK_SIZE);\n        const chunkY = floor(game.worldMouseY / CHUNK_SIZE);\n        if (chunkX >= 0 && chunkX < WORLD_SIZE && chunkY >= 0 && chunkY < WORLD_SIZE) {\n            textAlign(RIGHT, TOP);\n            fill(255);\n            textSize(14);\n            textFont(Fonts.bold);\n            const heat = game.world.heat[chunkY * WORLD_SIZE + chunkX];\n            text('Heat: ' + nf(heat, 1, 2), 50 * 16 + 200, 135);\n            textSize(12);\n            if (heat > game.temp) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 0, 255);\n            }\n            text(nf(heat - game.temp, 1, 2), 50 * 16 + 200, 150);\n        \n        }\n    }\n\n    textSize(16);\n\n    if (!game.extraInfo) {\n        textFont(Fonts.regular);\n        fill(255);\n        noStroke();\n        textAlign(LEFT, TOP);\n        text('Press Q for extra info', 50 * 16 + 20, 420);\n        return;\n    }\n\n    stroke(255);\n    noFill();\n    rect(50 * 16 + 220, 10, 200, 200);\n    rect(50 * 16 + 220, 220, 200, 200);\n    rect(50 * 16 + 220, 430, 510, 370);\n\n    fill(255);\n    noStroke();\n    textFont(Fonts.bold);\n    textAlign(LEFT, TOP);\n    text('Groups', 50 * 16 + 230, 20);\n    text('Top', 50 * 16 + 230, 230);\n    text('Stats', 50 * 16 + 230, 440);\n    \n    for (let i = 0; i < game.groups.length; i += 1) {\n        textAlign(LEFT, TOP);\n        textFont(Fonts.regular);\n        text(game.groups[i], 50 * 16 + 230, 40 + i * 20);\n\n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        text(game.people.reduce((acc, person) => person.surname === game.groups[i] ? acc + 1 : acc, 0), 50 * 16 + 410, 40 + i * 20);\n\n        if (mouseIsWithin(50 * 16 + 230, 40 + i * 20, 180, 20) && input.mouse[LEFT] === 1) {\n            jumpToPerson(game.people.find(person => person.surname === game.groups[i] && person.id !== game.selectedPerson));\n        }\n    }\n\n    const maxScore = game.people.reduce((acc, person) => max(acc, person.score), 0);\n    const topScorers = game.people.sort((a, b) => b.score - a.score).slice(0, 5);\n    for (let i = 0; i < topScorers.length; i += 1) {\n        const person = topScorers[i];\n        fill(255);\n        textAlign(LEFT, TOP);\n        textFont(Fonts.regular);\n        textSize(12);\n        text(person.fullName, 50 * 16 + 250, 250 + i * 30);\n        \n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        textSize(16);\n        text(Math.round(person.score), 50 * 16 + 410, 250 + i * 30);\n\n        drawNiceItem(person.display, 50 * 16 + 230, 250 + i * 30, 16);\n\n        stroke(255);\n        noFill();\n        rect(50 * 16 + 230, 270 + i * 30, 180, 5);\n\n        noStroke();\n        fill(255);\n        rect(50 * 16 + 230, 270 + i * 30, map(person.score, 0, maxScore, 0, 180), 5);\n\n        if (mouseIsWithin(50 * 16 + 230, 250 + i * 30, 180, 20) && input.mouse[LEFT] === 1) {\n            jumpToPerson(person);\n        }\n    }\n\n    fill(255);\n    noStroke();\n    textAlign(LEFT, TOP);\n    textSize(16);\n    textFont(Fonts.bold);\n    text('Deepest', 50 * 16 + 230, 460);\n    textFont(Fonts.regular);\n    if (game.deepestItemDepth > 0) {\n        drawNiceNoun({ type: 'thing', data: { selector: { conditions: [{ type: 'Is', data: game.deepestItem }] } } }, 50 * 16 + 300, 460);\n        \n        const person = game.people.find(person => person.fullName === game.deepestItemCredit);\n        if (person) {\n            drawNiceNoun({ type: 'person', data: { id: person.id }}, 50 * 16 + 320, 460);\n        } else {\n            textFont(Fonts.regular);\n            text('dead', 50 * 16 + 280, 460)\n        }\n        textFont(Fonts.bold);\n        fill(255);\n        text(`(${game.deepestItemDepth})`, 50 * 16 + 370, 460);\n    } else {\n        text('none', 50 * 16 + 300, 460);\n    }\n\n    const topCrafters = Object.entries(game.itemsCrafted).sort((a, b) => b[1] - a[1]).slice(0, 15);\n    const mostCrafted = topCrafters.reduce((acc, [_, count]) => max(acc, count), 0);\n    for (let i = 0; i < topCrafters.length; i += 1) {\n        const [id, count] = topCrafters[i];\n        drawNiceNoun({ type: 'thing', data: { selector: { conditions: [{ type: 'Is', data: +id }] } } }, 50 * 16 + 230, 490 + i * 20);\n\n        fill(255);\n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        textSize(16);\n        text(count, 50 * 16 + 410, 490 + i * 20);\n\n        stroke(255);\n        noFill();\n        rect(50 * 16 + 250, 495 + i * 20, 120, 5);\n\n        noStroke();\n        fill(255);\n        rect(50 * 16 + 250, 495 + i * 20, map(count, 0, mostCrafted, 0, 120), 5);\n    }\n\n    textFont(Fonts.bold);\n    textAlign(LEFT, TOP);\n    text('Yummy Foods', 50 * 16 + 430, 460);\n    \n    const topFoods = Object.entries(game.foodEaten).sort((a, b) => b[1] - a[1]).slice(0, 15);\n    const mostEaten = topFoods.reduce((acc, [_, count]) => max(acc, count), 0);\n    for (let i = 0; i < topFoods.length; i += 1) {\n        const [id, count] = topFoods[i];\n        drawNiceNoun({ type: 'thing', data: { selector: { conditions: [{ type: 'Is', data: +id }] } } }, 50 * 16 + 430, 490 + i * 20);\n\n        fill(255);\n        textFont(Fonts.bold);\n        textAlign(RIGHT, TOP);\n        textSize(16);\n        text(count, 50 * 16 + 610, 490 + i * 20);\n\n        stroke(255);\n        noFill();\n        rect(50 * 16 + 450, 495 + i * 20, 120, 5);\n\n        noStroke();\n        fill(255);\n        rect(50 * 16 + 450, 495 + i * 20, map(count, 0, mostEaten, 0, 120), 5);\n    }\n    \n\n    const selected = game.people.find(person => person.id === game.selectedPerson);\n    if (selected) {\n        // draw view rectangle\n        fill(255, 10);\n        noStroke();\n        rect(selected.x * 16 - game.camera.x * 16 - 9 * 16, selected.y * 16 - game.camera.y * 16 - 9 * 16, 19 * 16, 19 * 16);\n\n        if (selected.short['goto'] != null) {\n            stroke(255);\n            noFill();\n            ellipse((selected.short['goto'].x - game.camera.x) * 16 + 8, (selected.short['goto'].y - game.camera.y) * 16 + 8, 4, 4);\n        }\n\n        stroke(255);\n        fill(0);\n        rect(50 * 16 + 10, 430, 200, 300);\n        noStroke();\n        fill(255);\n        drawNiceItem(selected.display, 50 * 16 + 20, 440, 64);\n        textFont(Fonts.bold);\n        textSize(16);\n        fill(255);\n        textAlign(LEFT, TOP);\n        text(selected.name, 50 * 16 + 90, 440);\n        fill(COLORS[selected.color]);\n        text(selected.surname, 50 * 16 + 90, 460);\n\n        textFont(Fonts.regular);\n        fill(255);\n        text(`Age: ${nf((game.tick - selected.born) / 4 / 30 / 24 / 60, 0, 4)} years`, 50 * 16 + 20, 510);\n\n        fill(150, 0, 0);\n        rect(50 * 16 + 20, 540, map(selected.health, 0, 100, 0, 140), 10);\n        text(Math.round(selected.health), 50 * 16 + 170, 535);\n        stroke(255);\n        noFill();\n        rect(50 * 16 + 20, 540, 140, 10);\n\n        noStroke();\n        fill(0, 150, 0);\n        rect(50 * 16 + 20, 560, map(selected.hunger, 0, 100, 0, 140), 10);\n        text(Math.round(selected.hunger), 50 * 16 + 170, 555);\n        stroke(255);\n        noFill();\n        rect(50 * 16 + 20, 560, 140, 10);\n\n        noStroke();\n        fill(0, 0, 200);\n        rect(50 * 16 + 20, 580, 30, 10);\n        fill(0, 0, 100);\n        rect(50 * 16 + 50, 580, 30, 10);\n\n        fill(100, 0, 0);\n        rect(50 * 16 + 100, 580, 30, 10);\n        fill(200, 0, 0);\n        rect(50 * 16 + 130, 580, 30, 10);\n\n        stroke(255);\n        noFill();\n        rect(50 * 16 + 20, 580, 140, 10);\n        let tempX = map(selected.temperature, -15, 15, 0, 1);\n        noFill();\n        stroke(tempX * 255, 0, tempX * -255 + 255);\n        line(50 * 16 + 20 + tempX * 140, 580, 50 * 16 + 20 + tempX * 140, 590);\n        triangle(50 * 16 + 20 + tempX * 140 - 5, 595, 50 * 16 + 20 + tempX * 140 + 5, 595, 50 * 16 + 20 + tempX * 140, 590);\n        \n        noStroke();\n        fill(tempX * 255, 0, tempX * -255 + 255);\n        text(Math.round(selected.temperature * 10) / 10, 50 * 16 + 170, 575);\n\n        stroke(255);\n        noFill();\n        rect(50 * 16 + 20, 600, 140, 10);\n\n        noStroke();\n        colorMode(HSB, 255);\n        fill((millis() / 10) % 255, 255, 255);\n        text(Math.round(selected.score), 50 * 16 + 170, 595);\n        rect(50 * 16 + 20, 600, map(selected.score, 0, maxScore, 0, 140), 10);\n        colorMode(RGB);\n        \n        stroke(255);\n        noFill();\n        rect(50 * 16 + 20, 620, 140, 10);\n\n        const totalNeeds = Object.values(selected.needs).reduce((acc, need) => acc + need, 0);\n        let x = 0;\n        for (const need in selected.needs) {\n            const w = map(selected.needs[need], 0, totalNeeds, 0, 140);\n            switch (need) {\n                case 'hunger':\n                    fill(0, 150, 0);\n                    break;\n                case 'temperature':\n                    fill(0, 0, 200);\n                    break;\n                case 'health':\n                    fill(150, 0, 0);\n                    break;\n                case 'boredom':\n                    fill(100);\n                    break;\n            }\n            rect(50 * 16 + 20 + x, 620, w, 10);\n            x += w;\n        }\n\n        stroke(255);\n        fill(0);\n        rect(50 * 16 + 430, 10, 300, 410);\n\n        textFont(Fonts.bold);\n        textSize(16);\n        fill(255);\n        noStroke();\n        textAlign(LEFT, TOP);\n        text('Objectives', 50 * 16 + 440, 20);\n\n        let y = 0;\n        for(const objective of selected.objectives) {\n            textAlign(LEFT, TOP);\n            drawObjective(objective, 50 * 16 + 450, 40 + y * 20);\n            stroke(100);\n            noFill();\n            const children = objective.type === 'obtain' ? objective.data.children : [];\n            for (const child of children) {\n                const y2 = child;\n                const mid = (y + y2) / 2;\n                const diff = y2 - y - 1;\n                bezier(\n                    50 * 16 + 445, 50 + y * 20,\n                    50 * 16 + 440 - diff * 5, 50 + mid * 20,\n                    50 * 16 + 440 - diff * 5, 50 + mid * 20,\n                    50 * 16 + 445, 50 + y2 * 20,\n                );\n            }\n            y += 1;\n            if (y >= 20) {\n                break;\n            }\n        }\n    } else {\n        stroke(255);\n        fill(0);\n        rect(50 * 16 + 10, 430, 200, 50);\n        noStroke();\n        fill(255);\n        textFont(Fonts.regular);\n        textSize(16);\n        textAlign(LEFT, TOP);\n        text('None', 50 * 16 + 20, 445);\n    }\n}"],"names":["URLSearchParams","window","location","search","get"],"version":3,"file":"index.3f4a4b5a.js.map"}